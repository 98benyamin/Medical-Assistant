import asyncio
import logging
import requests
import json
import os
from datetime import datetime
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, MessageHandler, ContextTypes, filters
from telegram.error import TelegramError
from bs4 import BeautifulSoup
from fastapi import FastAPI, Request
from fastapi.responses import Response
import uvicorn
from threading import Lock

# ØªÙ†Ø¸ÛŒÙ… Ù„Ø§Ú¯
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)
logger = logging.getLogger(__name__)

# ØªÙˆÚ©Ù† Ùˆ ÙˆØ¨â€ŒÙ‡ÙˆÚ© Ø¬Ø¯ÛŒØ¯
TOKEN = '8123059269:AAHlvWT2ZZ3iC1ICRkmiuwTjBHvdM-NLy18'
WEBHOOK_URL = 'https://medical-assistant-rum5.onrender.com/webhook'

# Ø¢Ø¯Ø±Ø³ API Ù…ØªÙ†ÛŒ Ùˆ ØªØ­Ù„ÛŒÙ„ ØªØµÙˆÛŒØ±
TEXT_API_URL = 'https://text.pollinations.ai/openai'

# Ø´Ù†Ø§Ø³Ù‡ Ú©Ø§Ù†Ø§Ù„
CHANNEL_ID = '@bbbyyyrt'
CHANNEL_LINK = 'https://t.me/bbbyyyrt'

# Ù…Ø³ÛŒØ± ÙØ§ÛŒÙ„ Ø¯ÛŒØªØ§Ø¨ÛŒØ³
DATABASE_FILE = 'database.json'

# ØªØ§Ø¨Ø¹â€ŒÙ‡Ø§ÛŒ Ù…Ø¯ÛŒØ±ÛŒØª Ø¯ÛŒØªØ§Ø¨ÛŒØ³
def load_database():
    """Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø§Ø² ÙØ§ÛŒÙ„ Ø¯ÛŒØªØ§Ø¨ÛŒØ³"""
    if os.path.exists(DATABASE_FILE):
        with open(DATABASE_FILE, 'r', encoding='utf-8') as f:
            return json.load(f)
    return {
        "users": {},
        "statistics": {
            "total_messages": 0,
            "total_users": 0,
            "total_photos": 0
        },
        "admins": [6753257929]
    }

def save_database(data):
    """Ø°Ø®ÛŒØ±Ù‡ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¯Ø± ÙØ§ÛŒÙ„ Ø¯ÛŒØªØ§Ø¨ÛŒØ³"""
    with open(DATABASE_FILE, 'w', encoding='utf-8') as f:
        json.dump(data, f, ensure_ascii=False, indent=4)

def update_user_stats(user_id, username=None, first_name=None):
    """Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø¢Ù…Ø§Ø± Ú©Ø§Ø±Ø¨Ø±"""
    db = load_database()
    if str(user_id) not in db["users"]:
        db["users"][str(user_id)] = {
            "username": username,
            "first_name": first_name,
            "join_date": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "message_count": 0,
            "photo_count": 0,
            "last_activity": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        }
        db["statistics"]["total_users"] += 1
    
    db["users"][str(user_id)]["last_activity"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    save_database(db)
    return db

def increment_message_count(user_id, is_photo=False):
    """Ø§ÙØ²Ø§ÛŒØ´ ØªØ¹Ø¯Ø§Ø¯ Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§ÛŒ Ú©Ø§Ø±Ø¨Ø±"""
    db = load_database()
    if str(user_id) in db["users"]:
        if is_photo:
            db["users"][str(user_id)]["photo_count"] += 1
            db["statistics"]["total_photos"] += 1
        else:
            db["users"][str(user_id)]["message_count"] += 1
        db["statistics"]["total_messages"] += 1
        save_database(db)

def is_admin(user_id):
    """Ø¨Ø±Ø±Ø³ÛŒ Ø§Ø¯Ù…ÛŒÙ† Ø¨ÙˆØ¯Ù† Ú©Ø§Ø±Ø¨Ø±"""
    db = load_database()
    return user_id in db["admins"]

# Ø¯Ø³ØªÙˆØ±Ø§Øª Ø§Ø¯Ù…ÛŒÙ†
async def admin_panel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù†Ù…Ø§ÛŒØ´ Ù¾Ù†Ù„ Ø§Ø¯Ù…ÛŒÙ†"""
    user_id = update.effective_user.id
    if not is_admin(user_id):
        await update.message.reply_text("â›”ï¸ Ø´Ù…Ø§ Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ø§ÛŒÙ† Ø¨Ø®Ø´ Ø±Ø§ Ù†Ø¯Ø§Ø±ÛŒØ¯!")
        return

    db = load_database()
    stats = db["statistics"]
    active_users = sum(1 for user in db["users"].values() 
                      if (datetime.now() - datetime.strptime(user["last_activity"], "%Y-%m-%d %H:%M:%S")).days < 7)

    stats_message = (
        "ğŸ“Š Ø¢Ù…Ø§Ø± Ø±Ø¨Ø§Øª:\n\n"
        f"ğŸ‘¥ ØªØ¹Ø¯Ø§Ø¯ Ú©Ù„ Ú©Ø§Ø±Ø¨Ø±Ø§Ù†: {stats['total_users']}\n"
        f"ğŸ‘¤ Ú©Ø§Ø±Ø¨Ø±Ø§Ù† ÙØ¹Ø§Ù„ (7 Ø±ÙˆØ² Ø§Ø®ÛŒØ±): {active_users}\n"
        f"ğŸ’¬ ØªØ¹Ø¯Ø§Ø¯ Ú©Ù„ Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§: {stats['total_messages']}\n"
        f"ğŸ–¼ ØªØ¹Ø¯Ø§Ø¯ Ú©Ù„ ØªØµØ§ÙˆÛŒØ±: {stats['total_photos']}\n"
    )

    keyboard = [
        [InlineKeyboardButton("ğŸ“Š Ø¢Ù…Ø§Ø± ØªÙØµÛŒÙ„ÛŒ", callback_data="detailed_stats")],
        [InlineKeyboardButton("ğŸ‘¥ Ù„ÛŒØ³Øª Ú©Ø§Ø±Ø¨Ø±Ø§Ù†", callback_data="users_list")]
    ]
    await update.message.reply_text(stats_message, reply_markup=InlineKeyboardMarkup(keyboard))

async def detailed_stats(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù†Ù…Ø§ÛŒØ´ Ø¢Ù…Ø§Ø± ØªÙØµÛŒÙ„ÛŒ"""
    query = update.callback_query
    await query.answer()
    
    if not is_admin(query.from_user.id):
        await query.edit_message_text("â›”ï¸ Ø´Ù…Ø§ Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ø§ÛŒÙ† Ø¨Ø®Ø´ Ø±Ø§ Ù†Ø¯Ø§Ø±ÛŒØ¯!")
        return

    db = load_database()
    users = db["users"]
    
    # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¢Ù…Ø§Ø±
    today_active = sum(1 for user in users.values() 
                      if (datetime.now() - datetime.strptime(user["last_activity"], "%Y-%m-%d %H:%M:%S")).days < 1)
    week_active = sum(1 for user in users.values() 
                     if (datetime.now() - datetime.strptime(user["last_activity"], "%Y-%m-%d %H:%M:%S")).days < 7)
    month_active = sum(1 for user in users.values() 
                      if (datetime.now() - datetime.strptime(user["last_activity"], "%Y-%m-%d %H:%M:%S")).days < 30)

    stats_message = (
        "ğŸ“Š Ø¢Ù…Ø§Ø± ØªÙØµÛŒÙ„ÛŒ:\n\n"
        f"ğŸ“… Ú©Ø§Ø±Ø¨Ø±Ø§Ù† ÙØ¹Ø§Ù„ Ø§Ù…Ø±ÙˆØ²: {today_active}\n"
        f"ğŸ“† Ú©Ø§Ø±Ø¨Ø±Ø§Ù† ÙØ¹Ø§Ù„ Ù‡ÙØªÙ‡: {week_active}\n"
        f"ğŸ“… Ú©Ø§Ø±Ø¨Ø±Ø§Ù† ÙØ¹Ø§Ù„ Ù…Ø§Ù‡: {month_active}\n"
        f"ğŸ’¬ Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† Ù¾ÛŒØ§Ù… Ù‡Ø± Ú©Ø§Ø±Ø¨Ø±: {db['statistics']['total_messages'] / len(users) if users else 0:.1f}\n"
        f"ğŸ–¼ Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† ØªØµÙˆÛŒØ± Ù‡Ø± Ú©Ø§Ø±Ø¨Ø±: {db['statistics']['total_photos'] / len(users) if users else 0:.1f}\n"
    )

    keyboard = [[InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="back_to_admin")]]
    await query.edit_message_text(stats_message, reply_markup=InlineKeyboardMarkup(keyboard))

async def users_list(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù†Ù…Ø§ÛŒØ´ Ù„ÛŒØ³Øª Ú©Ø§Ø±Ø¨Ø±Ø§Ù†"""
    query = update.callback_query
    await query.answer()
    
    if not is_admin(query.from_user.id):
        await query.edit_message_text("â›”ï¸ Ø´Ù…Ø§ Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ø§ÛŒÙ† Ø¨Ø®Ø´ Ø±Ø§ Ù†Ø¯Ø§Ø±ÛŒØ¯!")
        return

    db = load_database()
    users = db["users"]
    
    # Ù…Ø±ØªØ¨â€ŒØ³Ø§Ø²ÛŒ Ú©Ø§Ø±Ø¨Ø±Ø§Ù† Ø¨Ø± Ø§Ø³Ø§Ø³ Ø¢Ø®Ø±ÛŒÙ† ÙØ¹Ø§Ù„ÛŒØª
    sorted_users = sorted(users.items(), 
                         key=lambda x: datetime.strptime(x[1]["last_activity"], "%Y-%m-%d %H:%M:%S"),
                         reverse=True)[:10]  # Ù†Ù…Ø§ÛŒØ´ 10 Ú©Ø§Ø±Ø¨Ø± Ø¢Ø®Ø±

    users_message = "ğŸ‘¥ Ø¢Ø®Ø±ÛŒÙ† Ú©Ø§Ø±Ø¨Ø±Ø§Ù† ÙØ¹Ø§Ù„:\n\n"
    for user_id, user_data in sorted_users:
        users_message += (
            f"ğŸ‘¤ Ù†Ø§Ù…: {user_data['first_name']}\n"
            f"ğŸ†” ÛŒÙˆØ²Ø±Ù†ÛŒÙ…: @{user_data['username'] if user_data['username'] else 'Ù†Ø¯Ø§Ø±Ø¯'}\n"
            f"ğŸ’¬ ØªØ¹Ø¯Ø§Ø¯ Ù¾ÛŒØ§Ù…: {user_data['message_count']}\n"
            f"ğŸ–¼ ØªØ¹Ø¯Ø§Ø¯ ØªØµÙˆÛŒØ±: {user_data['photo_count']}\n"
            f"â± Ø¢Ø®Ø±ÛŒÙ† ÙØ¹Ø§Ù„ÛŒØª: {user_data['last_activity']}\n"
            "â–â–â–â–â–â–â–â–\n"
        )

    keyboard = [[InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="back_to_admin")]]
    await query.edit_message_text(users_message, reply_markup=InlineKeyboardMarkup(keyboard))

async def back_to_admin(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ù¾Ù†Ù„ Ø§Ø¯Ù…ÛŒÙ†"""
    query = update.callback_query
    await query.answer()
    await admin_panel(update, context)

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… Ø®ÙˆØ´â€ŒØ¢Ù…Ø¯Ú¯ÙˆÛŒÛŒ Ø¨Ø§ Ø¨Ø±Ø±Ø³ÛŒ Ø¹Ø¶ÙˆÛŒØª Ø¯Ø± Ú©Ø§Ù†Ø§Ù„"""
    user = update.effective_user
    user_id = user.id
    
    # Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø¢Ù…Ø§Ø± Ú©Ø§Ø±Ø¨Ø±
    update_user_stats(user_id, user.username, user.first_name)

    if user_id in AI_CHAT_USERS:
        AI_CHAT_USERS.remove(user_id)
    context.user_data.clear()

    is_member = await check_channel_membership(context.bot, user_id)
    if not is_member:
        welcome_message = clean_text(
            f"Ø³Ù„Ø§Ù… {user.first_name}!\nØ¨Ø±Ø§ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø¯Ø³ØªÛŒØ§Ø± Ù¾Ø²Ø´Ú©ÛŒØŒ Ø¨Ø§ÛŒØ¯ ØªÙˆ Ú©Ø§Ù†Ø§Ù„ Ø¹Ø¶Ùˆ Ø¨Ø´ÛŒ! ğŸ¥\n"
            "Ù„Ø·ÙØ§Ù‹ ØªÙˆ Ú©Ø§Ù†Ø§Ù„ Ø¹Ø¶Ùˆ Ø´Ùˆ Ùˆ Ø¨Ø¹Ø¯ Ø¯Ú©Ù…Ù‡ 'Ø¹Ø¶Ùˆ Ø´Ø¯Ù…' Ø±Ùˆ Ø¨Ø²Ù†! ğŸš‘"
        )
        keyboard = [
            [InlineKeyboardButton("Ø¹Ø¶Ùˆ Ú©Ø§Ù†Ø§Ù„ Ø´Ùˆ ğŸ“¢", url=CHANNEL_LINK)],
            [InlineKeyboardButton("Ø¹Ø¶Ùˆ Ø´Ø¯Ù…! âœ…", callback_data="check_membership")]
        ]
        await update.message.reply_text(welcome_message, reply_markup=InlineKeyboardMarkup(keyboard))
        return

    welcome_message = clean_text(
        f"Ø³Ù„Ø§Ù… {user.first_name}!\nØ¨Ù‡ Ø¯Ø³ØªÛŒØ§Ø± Ù¾Ø²Ø´Ú©ÛŒ Ù‡ÙˆØ´Ù…Ù†Ø¯ Ø®ÙˆØ´ Ø§ÙˆÙ…Ø¯ÛŒ! ğŸ©º\n"
        "Ù…ÛŒâ€ŒØªÙˆÙ†ÛŒ Ø¯Ø±Ø¨Ø§Ø±Ù‡ Ø¨ÛŒÙ…Ø§Ø±ÛŒâ€ŒÙ‡Ø§ØŒ Ø¯Ø§Ø±ÙˆÙ‡Ø§ØŒ Ø¨Ø±Ú¯Ù‡ Ø¢Ø²Ù…Ø§ÛŒØ´ ÛŒØ§ Ù†ÙˆØ§Ø± Ù‚Ù„Ø¨ Ø³Ø¤Ø§Ù„ Ú©Ù†ÛŒ. Ú†ÛŒ ØªÙˆ Ø³Ø±ØªÙ‡ØŸ ğŸ§‘ğŸ»â€âš•"
    )
    keyboard = [
        [InlineKeyboardButton("Ø´Ø±ÙˆØ¹ Ù…Ø´Ø§ÙˆØ±Ù‡ Ù¾Ø²Ø´Ú©ÛŒ ğŸ¤–", callback_data="chat_with_ai")]
    ]
    await update.message.reply_text(welcome_message, reply_markup=InlineKeyboardMarkup(keyboard))

async def handle_ai_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù…Ø¯ÛŒØ±ÛŒØª Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§ÛŒ Ù…ØªÙ†ÛŒ Ú©Ø§Ø±Ø¨Ø± Ø¯Ø± Ø­Ø§Ù„Øª Ú†Øª Ø¨Ø§ Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ"""
    user = update.effective_user
    user_id = user.id
    
    # Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø¢Ù…Ø§Ø± Ú©Ø§Ø±Ø¨Ø±
    update_user_stats(user_id, user.username, user.first_name)
    increment_message_count(user_id)
    
    if user_id not in AI_CHAT_USERS or context.user_data.get("mode") != "ai_chat":
        return

    message_id = update.message.message_id
    with PROCESSING_LOCK:
        if message_id in PROCESSED_MESSAGES:
            logger.warning(f"Ù¾ÛŒØ§Ù… ØªÚ©Ø±Ø§Ø±ÛŒ Ø¨Ø§ message_id: {message_id} - Ù†Ø§Ø¯ÛŒØ¯Ù‡ Ú¯Ø±ÙØªÙ‡ Ø´Ø¯")
            return
        PROCESSED_MESSAGES.add(message_id)

    chat_id = update.message.chat_id
    user_message = update.message.text
    chat_history = context.user_data.get("chat_history", [])
    chat_history.append({"role": "user", "content": user_message})
    context.user_data["chat_history"] = chat_history

    # Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… Ù…ÙˆÙ‚Øª
    temp_message = await update.message.reply_text(clean_text("ğŸ©º"))

    payload = {
        "model": "openai-large",
        "messages": [
            {"role": "system", "content": SYSTEM_MESSAGE}
        ] + chat_history,
        "max_tokens": 300,
        "seed": 42,
        "json_mode": False
    }

    keyboard = [[InlineKeyboardButton("ğŸ  Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ", callback_data="back_to_home")]]
    reply_markup = InlineKeyboardMarkup(keyboard)

    try:
        response = requests.post(TEXT_API_URL, json=payload, timeout=20)
        # Ø­Ø°Ù Ù¾ÛŒØ§Ù… Ù…ÙˆÙ‚Øª
        try:
            await context.bot.delete_message(chat_id=chat_id, message_id=temp_message.message_id)
        except TelegramError as e:
            logger.error(f"Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ù¾ÛŒØ§Ù… Ù…ÙˆÙ‚Øª: {e}")

        if response.status_code == 200:
            response_data = response.json()
            ai_response = response_data.get("choices", [{}])[0].get("message", {}).get("content", "Ù¾Ø§Ø³Ø®ÛŒ Ø¯Ø±ÛŒØ§ÙØª Ù†Ø´Ø¯!")
            ai_response = clean_text(ai_response.strip())
            chat_history.append({"role": "assistant", "content": ai_response})
            context.user_data["chat_history"] = chat_history
            await update.message.reply_text(ai_response, reply_markup=reply_markup)
        else:
            await update.message.reply_text(
                clean_text("Ø§ÙˆÙ¾Ø³ØŒ Ø³ÛŒØ³ØªÙ… Ù¾Ø²Ø´Ú©ÛŒâ€ŒÙ…ÙˆÙ† ÛŒÙ‡ Ù„Ø­Ø¸Ù‡ Ù‚ÙÙ„ Ú©Ø±Ø¯! ğŸ©º Ù„Ø·ÙØ§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø³Ø¤Ø§Ù„Øª Ø±Ùˆ Ø¨ÙØ±Ø³Øª. ğŸ˜Š"),
                reply_markup=reply_markup
            )
    except Exception as e:
        try:
            await context.bot.delete_message(chat_id=chat_id, message_id=temp_message.message_id)
        except TelegramError as e:
            logger.error(f"Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ù¾ÛŒØ§Ù… Ù…ÙˆÙ‚Øª: {e}")
        logger.error(f"Ø®Ø·Ø§ Ø¯Ø± Ø§ØªØµØ§Ù„ Ø¨Ù‡ API Ú†Øª: {e}")
        await update.message.reply_text(
            clean_text("Ø§ÙˆÙ‡ØŒ Ø§Ù†Ú¯Ø§Ø± Ø§Ø¨Ø²Ø§Ø± ØªØ´Ø®ÛŒØµâ€ŒÙ…ÙˆÙ† Ù†ÛŒØ§Ø² Ø¨Ù‡ Ø¨Ø±Ø±Ø³ÛŒ Ø¯Ø§Ø±Ù‡! ğŸ’‰ Ù„Ø·ÙØ§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø³Ø¤Ø§Ù„Øª Ø±Ùˆ Ø¨ÙØ±Ø³Øª. ğŸ˜Š"),
            reply_markup=reply_markup
        )

async def handle_photo(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù…Ø¯ÛŒØ±ÛŒØª Ø¹Ú©Ø³â€ŒÙ‡Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„ÛŒ Ùˆ ØªØ­Ù„ÛŒÙ„ Ø¨Ø§ API Pollinations"""
    user = update.effective_user
    user_id = user.id
    
    # Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø¢Ù…Ø§Ø± Ú©Ø§Ø±Ø¨Ø±
    update_user_stats(user_id, user.username, user.first_name)
    increment_message_count(user_id, is_photo=True)
    
    if user_id not in AI_CHAT_USERS or context.user_data.get("mode") != "ai_chat":
        return

    message_id = update.message.message_id
    with PROCESSING_LOCK:
        if message_id in PROCESSED_MESSAGES:
            logger.warning(f"Ù¾ÛŒØ§Ù… ØªÚ©Ø±Ø§Ø±ÛŒ Ø¨Ø§ message_id: {message_id} - Ù†Ø§Ø¯ÛŒØ¯Ù‡ Ú¯Ø±ÙØªÙ‡ Ø´Ø¯")
            return
        PROCESSED_MESSAGES.add(message_id)

    chat_id = update.message.chat_id
    keyboard = [[InlineKeyboardButton("ğŸ  Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ", callback_data="back_to_home")]]
    reply_markup = InlineKeyboardMarkup(keyboard)

    # Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… Ù…ÙˆÙ‚Øª
    temp_message = await update.message.reply_text(clean_text("ğŸ”¬"))

    # Ø¯Ø±ÛŒØ§ÙØª Ø¹Ú©Ø³ Ø¨Ø§ Ø¨Ø§Ù„Ø§ØªØ±ÛŒÙ† Ú©ÛŒÙÛŒØª
    photo = update.message.photo[-1]
    file = await context.bot.get_file(photo.file_id)
    file_url = file.file_path

    # Ø¨Ø±Ø±Ø³ÛŒ Ú©Ù¾Ø´Ù† (Ø§Ú¯Ø± ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ø¯)
    caption = update.message.caption if update.message.caption else "Ø§ÛŒÙ† ØªØµÙˆÛŒØ± Ù¾Ø²Ø´Ú©ÛŒ (Ù…Ø«Ù„ Ø¨Ø±Ú¯Ù‡ Ø¢Ø²Ù…Ø§ÛŒØ´ ÛŒØ§ Ù†ÙˆØ§Ø± Ù‚Ù„Ø¨) Ú†ÛŒÙ‡ØŸ Ø¨Ù‡â€ŒØµÙˆØ±Øª Ø®Ù„Ø§ØµÙ‡ Ùˆ Ø¯Ù‚ÛŒÙ‚ ØªØ­Ù„ÛŒÙ„ Ú©Ù†! ğŸ©º"

    # Ø¢Ù…Ø§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ù¾ÛŒØ§Ù… Ø¨Ø±Ø§ÛŒ ØªØ­Ù„ÛŒÙ„ ØªØµÙˆÛŒØ±
    chat_history = context.user_data.get("chat_history", [])
    image_message = {
        "role": "user",
        "content": [
            {"type": "text", "text": caption},
            {"type": "image_url", "image_url": {"url": file_url}}
        ]
    }
    chat_history.append(image_message)
    context.user_data["chat_history"] = chat_history

    payload = {
        "model": "openai-large",
        "messages": [
            {"role": "system", "content": SYSTEM_MESSAGE}
        ] + chat_history,
        "max_tokens": 300,
        "seed": 42,
        "json_mode": False
    }

    try:
        response = requests.post(TEXT_API_URL, json=payload, timeout=20)
        # Ø­Ø°Ù Ù¾ÛŒØ§Ù… Ù…ÙˆÙ‚Øª
        try:
            await context.bot.delete_message(chat_id=chat_id, message_id=temp_message.message_id)
        except TelegramError as e:
            logger.error(f"Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ù¾ÛŒØ§Ù… Ù…ÙˆÙ‚Øª: {e}")

        if response.status_code == 200:
            response_data = response.json()
            ai_response = response_data.get("choices", [{}])[0].get("message", {}).get("content", "Ù¾Ø§Ø³Ø®ÛŒ Ø¯Ø±ÛŒØ§ÙØª Ù†Ø´Ø¯!")
            ai_response = clean_text(ai_response.strip())
            chat_history.append({"role": "assistant", "content": ai_response})
            context.user_data["chat_history"] = chat_history
            await update.message.reply_text(ai_response, reply_markup=reply_markup)
        else:
            await update.message.reply_text(
                clean_text("Ø§ÙˆÙ‡ØŒ Ø¯Ø³ØªÚ¯Ø§Ù‡ ØªØ­Ù„ÛŒÙ„â€ŒÙ…ÙˆÙ† Ù†ÛŒØ§Ø² Ø¨Ù‡ ØªÙ†Ø¸ÛŒÙ… Ø¯Ø§Ø±Ù‡! ğŸ’‰ Ù„Ø·ÙØ§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø¹Ú©Ø³ Ø±Ùˆ Ø¨ÙØ±Ø³Øª. ğŸ©»"),
                reply_markup=reply_markup
            )
    except Exception as e:
        try:
            await context.bot.delete_message(chat_id=chat_id, message_id=temp_message.message_id)
        except TelegramError as e:
            logger.error(f"Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù Ù¾ÛŒØ§Ù… Ù…ÙˆÙ‚Øª: {e}")
        logger.error(f"Ø®Ø·Ø§ Ø¯Ø± ØªØ­Ù„ÛŒÙ„ ØªØµÙˆÛŒØ±: {e}")
        await update.message.reply_text(
            clean_text("Ø§ÙˆÙ¾Ø³ØŒ Ø§Ø³Ú©Ù†Ø± Ù¾Ø²Ø´Ú©ÛŒâ€ŒÙ…ÙˆÙ† ÛŒÙ‡ Ù„Ø­Ø¸Ù‡ Ø®Ø§Ù…ÙˆØ´ Ø´Ø¯! ğŸ©º Ù„Ø·ÙØ§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø¹Ú©Ø³ Ø±Ùˆ Ø¨ÙØ±Ø³Øª. ğŸ˜Š"),
            reply_markup=reply_markup
        )

async def main():
    """Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø±Ø¨Ø§Øª Ø¨Ø§ ÙˆØ¨â€ŒÙ‡ÙˆÚ© Ùˆ Ø³Ø±ÙˆØ± FastAPI"""
    global application
    try:
        # Ø³Ø§Ø®Øª Ø§Ù¾Ù„ÛŒÚ©ÛŒØ´Ù† Ø¨Ø§ ØªÙˆÚ©Ù†
        application = Application.builder().token(TOKEN).read_timeout(60).write_timeout(60).connect_timeout(60).build()

        # ØªÙ†Ø¸ÛŒÙ… ÙˆØ¨â€ŒÙ‡ÙˆÚ©
        await application.bot.set_webhook(url=WEBHOOK_URL)
        logger.info(f"Webhook Ø±ÙˆÛŒ {WEBHOOK_URL} ØªÙ†Ø¸ÛŒÙ… Ø´Ø¯.")

        # Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ù‡Ù†Ø¯Ù„Ø±Ù‡Ø§
        application.add_handler(CommandHandler("start", start, filters=filters.ChatType.PRIVATE))
        application.add_handler(CommandHandler("admin", admin_panel, filters=filters.ChatType.PRIVATE))
        application.add_handler(CallbackQueryHandler(check_membership, pattern="^check_membership$"))
        application.add_handler(CallbackQueryHandler(chat_with_ai, pattern="^chat_with_ai$"))
        application.add_handler(CallbackQueryHandler(back_to_home, pattern="^back_to_home$"))
        application.add_handler(CallbackQueryHandler(detailed_stats, pattern="^detailed_stats$"))
        application.add_handler(CallbackQueryHandler(users_list, pattern="^users_list$"))
        application.add_handler(CallbackQueryHandler(back_to_admin, pattern="^back_to_admin$"))
        application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND & filters.ChatType.PRIVATE, handle_ai_message))
        application.add_handler(MessageHandler(filters.PHOTO & filters.ChatType.PRIVATE, handle_photo))

        # Ø´Ø±ÙˆØ¹ Ø±Ø¨Ø§Øª
        logger.info("Ø¯Ø± Ø­Ø§Ù„ Ø¢Ù…Ø§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø±Ø¨Ø§Øª...")
        await application.initialize()
        logger.info("Ø¯Ø± Ø­Ø§Ù„ Ø´Ø±ÙˆØ¹ Ø±Ø¨Ø§Øª...")
        await application.start()

        # Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø³Ø±ÙˆØ± FastAPI
        config = uvicorn.Config(app, host="0.0.0.0", port=8000)
        server = uvicorn.Server(config)
        await server.serve()

    except Exception as e:
        logger.error(f"Ø®Ø·Ø§ Ø¯Ø± Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø±Ø¨Ø§Øª: {e}")
        raise

if __name__ == "__main__":
    asyncio.run(main()) 
